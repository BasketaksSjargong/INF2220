#Generalized Pattern Matching With Wildcards
## Third mandatory assignment in INF2220
The task at hand is to implement a generalization of the Boyer-Moore-Horspool bad
character shift algorithm to allow wildcards to be used in the needle.

* Implement a pattern matching algorithm using bad character shift.
* Algorithm must be able to handle several wildcards.
* Implementation must be able to find all occurences of the needle and report the position.
* Program must format the results in an easy-to-read manner.
* The program must output the text in the haystack that matched the needle.
* The program must take two filenames as an argument. First being the needle and second the haystack.

### Bad Character Shift explained:
Bad character shift is a table over all possible characters, that specify how far to shiftthe needle if one finds the character at the end of the needle. That means you have to subtract the number of characters already matched before jumping. Each character is given a shift value that is equal to the length of the needle minus the index of the last occurence of the character. Any character not occuring in the needle is given a character shift equal to the
length of the word.

#### Preprocessing
Create a table of 256 members, one for each character in the alphabet. Initialize all the values with the length of the needle.
Generate the bad character shift values for each character in the needle.

### Bad Character Shift with wildcards:
The question now is what role does the wildcard play into all this.
Let _ denote a wildcard.
While searching for a needle with a wildcard, we can simply chose to only
try to match up characters up until the first wildcard occurs, because this is going to match by
definition. We therefore only have to create the bad character shift values for the first clause of
non wild-card characters. That means for a needle AB _ _ CD _ _ EF _ _ _ only the string "EF" has to be accounted for.

## Class overview

### PatternMatcher.java
This is the class containing the main method.
It uses the Scanner module for reading the needle and haystack from file.
If no valid needle or haystack is found it exits.

It calls the BoyerMooreHorspool.startSearch() method.

### BoyerMooreHorspool.java
This is the class that contains the implementation of the Boyer-Moore-Hoorspool
algorithm. 

#### Method overview:
* generateBadCharTable()
* getSubString()
* startSearch()
* stripChar()

##### generateBadCharTable()
This is the method that generates the bad character shift table.
It uses the normal method for generating this, with a modification.
In order to add wildcard functionality it only uses the rightmost non-wildcard
part of the needle. This is generated by the stripChar method. There could be ways
to improve this method. Say fpr 

###### Complexity
Let N be the length of the needle and M the length of the haystack.
The method has one single call to the method stripChar() along all the
other constant time operations. 

* O(N)

##### getSubString()
This is an auxilliary method used for returning the needle matches.
###### Complexity
Just a single call, thus constant complexity

* O(1)

##### startSearch()
This is the working unit of the implementation. It attempts to match
the needle to the current window in the haystack, starting at the end.
If it finds a character that does not match, it shifts the window using
the bad character table. If all the characters match, output is generated
specifying where the match occured, and what the match was.

###### Complexity
Let N be the length of the needle and M the length of the haystack.
Worst case, the while loop runs M times.
For each iteration in the while loop there is a for loop that, worst case, N times. For each iteration
in the for loop there is an if-else clause. Worst case, this uses three units of time.
Outside the for loop there is a single if statement of constant time.
All together, this gives a worst case of

* O(NM)

##### stripChar()
This is the method that enables wildcarding in an easy manner.
This takes a character array as input (needle) and returns a character array
that consists of the rightmost subarray of consecutive non-wildcard characters.

###### Complexity 
Let N be the length of the needle
Consistng of two for loops. Worst case, this gives

* O(N)

### How to run
##### Compilation

	javac PatternMatcher.java BoyerMooreHorspool.java

##### Running:

	java PatternMatcher needle.txt haystack.txt

##### Expected Test Results:

###### Test 1

	java PatternMatcher needle1.txt haystack1.txt
	
should yield the result:

	=====================
	Needle: heisanndå
	---------------------
	Match : heisanndå
	Start : 30
	Stop  : 38			

###### Test 2

	java PatternMatcher needle2.txt haystack2.txt

should yield the result:

	=====================
	Needle: __hello_bye
	---------------------
	Match : aahellobbye
	Start : 36
	Stop  : 46			
	=====================
	Needle: __hello_bye
	---------------------
	Match : bchellotbye
	Start : 53
	Stop  : 63			

###### Test 3

	java PatternMatcher needle3.txt haystack3.txt

should yield the result: 

	=====================
	Needle: _____
	---------------------
	Match : sklas
	Start : 0
	Stop  : 4			
	=====================
	Needle: _____
	---------------------
	Match : klasa
	Start : 1
	Stop  : 5			
	=====================
	Needle: _____
	---------------------
	Match : lasaj
	Start : 2
	Stop  : 6			

### Comment

##### Assumptions:

In this implementation, I've assumed that the needle does not contain any whitespaces.

##### Credit:

The code that reads files as one line was taken from the top answer at:
http://stackoverflow.com/questions/3402735/what-is-simplest-way-to-read-a-file-into-string

